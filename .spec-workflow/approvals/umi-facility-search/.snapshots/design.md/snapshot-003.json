{
  "id": "snapshot_1764946567986_skvw9g90a",
  "approvalId": "approval_1764946562330_6wb102444",
  "approvalTitle": "設計ドキュメント (design.md) の承認 [修正版]",
  "version": 3,
  "timestamp": "2025-12-05T14:56:07.986Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## 概要\n\n宇美町施設予約検索システム（umi-facility-search）は、Next.js 15.x (App Router)を使用したモバイルファーストのWebアプリケーションです。本設計では、requirements.mdで定義された6つの主要要件を実現するための技術設計を詳細に定義します。\n\n### システムの位置づけ\n\n本システムは、既存の宇美町施設予約確認システムのデータソースとして利用し、ユーザーフレンドリーな代替インターフェースを提供します。スクレイピングによるデータ取得、モバイル最適化されたUI、適切なエラーハンドリングを実装します。\n\n## ステアリングドキュメントとの整合性\n\n### 技術標準 (tech.md)\n\n本設計は、tech.mdで定義された技術スタックに完全準拠します：\n\n- **Next.js 15.x (App Router)**: サーバーコンポーネントとクライアントコンポーネントの使い分け\n- **TypeScript**: 100%型安全なコード\n- **TailwindCSS**: モバイルファーストのレスポンシブデザイン\n- **Puppeteer**: 信頼性の高いスクレイピング\n- **pnpm 9.x**: パッケージ管理\n- **Node.js 20.x**: Vercel推奨LTSバージョン\n\n### プロジェクト構造 (structure.md)\n\n本設計は、structure.mdで定義されたディレクトリ構造と命名規則に従います：\n\n```\nsrc/\n├── app/                          # Next.js App Router\n│   ├── page.tsx                 # トップページ（検索フォーム）\n│   ├── api/\n│   │   └── scrape/\n│   │       └── route.ts         # スクレイピングAPI\n│   └── results/\n│       └── page.tsx             # 検索結果ページ\n├── components/                   # Reactコンポーネント\n│   ├── ui/                      # 汎用UIコンポーネント\n│   ├── SearchForm.tsx\n│   ├── FacilityCard.tsx\n│   └── AvailabilityList.tsx\n├── lib/                         # ビジネスロジック\n│   ├── scraper/                # スクレイピング関連\n│   ├── utils/                  # ユーティリティ関数\n│   └── types/                  # TypeScript型定義\n└── styles/\n    └── globals.css\n```\n\n**命名規則:**\n- コンポーネント: `PascalCase.tsx`\n- ユーティリティ: `camelCase.ts`\n- 型定義: `PascalCase`\n- 関数: `camelCase`\n- 定数: `UPPER_SNAKE_CASE`\n\n## コード再利用分析\n\n### 既存コンポーネントの活用\n\n本プロジェクトは新規作成のため、既存コンポーネントはありません。ただし、以下の外部ライブラリを活用します：\n\n- **Next.js組み込みコンポーネント**: `Link`, `Image`（最適化のため）\n- **Headless UIライブラリ（将来検討）**: 日付ピッカー、モーダルなど\n- **date-fns**: 日付操作（軽量で型安全）\n\n### 統合ポイント\n\n- **宇美町システム**: スクレイピングによるデータ取得（https://www.11489.jp/Umi/web/Home/WgR_ModeSelect）\n- **Vercelデプロイ**: 環境変数による設定管理\n- **将来的な拡張**: Vercel KV (Redis)によるキャッシュ（初期バージョンでは未実装）\n\n## アーキテクチャ\n\n### モジュラー設計原則\n\n1. **単一ファイル責任**: 各ファイルは1つの明確な責任を持つ\n2. **コンポーネント分離**: 小さく焦点を絞ったコンポーネントを作成\n3. **サービスレイヤー分離**: データアクセス、ビジネスロジック、プレゼンテーションを分離\n4. **ユーティリティモジュール化**: 単一目的の焦点を絞ったユーティリティ\n\n### レイヤーアーキテクチャ\n\n```mermaid\ngraph TD\n    A[Presentation Layer<br/>React Components] --> B[Business Logic Layer<br/>lib/utils]\n    B --> C[Data Access Layer<br/>lib/scraper]\n    C --> D[External Service<br/>宇美町システム]\n    \n    E[API Routes<br/>app/api] --> B\n    E --> C\n```\n\n**依存関係の方向:**\n- プレゼンテーション → ビジネスロジック → データアクセス → 外部サービス\n- 下位レイヤーは上位レイヤーに依存しない\n\n### レンダリング戦略\n\n1. **検索フォーム（トップページ）**: クライアントサイドレンダリング（CSR）\n   - ユーザーインタラクションが多い\n   - `'use client'` ディレクティブを使用\n\n2. **検索結果ページ**: サーバーサイドレンダリング（SSR）\n   - APIからデータを取得して表示\n   - SEOは不要だが、初回表示を高速化\n\n3. **API Routes**: サーバーサイド\n   - スクレイピング処理を実行\n   - レート制限を実装\n\n## コンポーネントとインターフェース\n\n### 1. SearchForm コンポーネント\n\n**目的**: 日付と時間帯を選択して検索を実行するフォーム\n\n**ファイル**: `src/components/SearchForm.tsx`\n\n**Props:**\n```typescript\ninterface SearchFormProps {\n  onSubmit: (params: SearchParams) => void;\n  isLoading: boolean;\n}\n\ninterface SearchParams {\n  dates: Date[];           // 選択された日付の配列\n  timeRange?: TimeRange;   // オプションの時間範囲\n}\n\ninterface TimeRange {\n  from: string;  // 開始時刻（例: \"9:00\"）\n  to: string;    // 終了時刻（例: \"12:00\"）\n}\n```\n\n**依存関係:**\n- `DatePicker` (UI component)\n- `TimePicker` (UI component)\n- `Button` (UI component)\n- `date-fns` (日付操作)\n\n**再利用するもの:**\n- TailwindCSSのモバイルファーストスタイル\n- Reactのフォーム管理（useState, useEffect）\n\n**責任:**\n- 日付選択UIの表示\n- 「本日から1週間」クイックボタン\n- バリデーション（日付未選択エラー）\n- 検索パラメータの送信\n\n### 2. DatePicker コンポーネント\n\n**目的**: 複数日選択可能なカレンダーUI\n\n**ファイル**: `src/components/ui/DatePicker.tsx`\n\n**Props:**\n```typescript\ninterface DatePickerProps {\n  selectedDates: Date[];\n  onChange: (dates: Date[]) => void;\n  minDate?: Date;  // 過去日の選択を制限\n}\n```\n\n**依存関係:**\n- `date-fns` (日付計算)\n\n**再利用するもの:**\n- TailwindCSSグリッドレイアウト\n\n**責任:**\n- カレンダーグリッドの表示\n- 複数日の選択/解除\n- 選択された日付の視覚的な強調\n\n### 3. QuickDateSelect コンポーネント\n\n**目的**: 「本日から1週間」ボタンによるクイック日付選択\n\n**ファイル**: `src/components/ui/QuickDateSelect.tsx`\n\n**Props:**\n```typescript\ninterface QuickDateSelectProps {\n  onQuickSelect: (dates: Date[]) => void;\n}\n```\n\n**依存関係:**\n- `date-fns` (日付生成)\n\n**責任:**\n- 本日から7日間の配列を生成\n- ボタンクリックでコールバック実行\n\n### 4. TimePicker コンポーネント\n\n**目的**: 時間範囲選択UI（From - To）\n\n**ファイル**: `src/components/ui/TimePicker.tsx`\n\n**Props:**\n```typescript\ninterface TimePickerProps {\n  selectedRange?: TimeRange;\n  onChange: (range: TimeRange | undefined) => void;\n}\n\ninterface TimeRange {\n  from: string;  // 開始時刻（例: \"9:00\"）\n  to: string;    // 終了時刻（例: \"12:00\"）\n}\n```\n\n**依存関係:** なし\n\n**責任:**\n- 開始時刻（From）のドロップダウン表示（8:30, 9:00, 9:30, ...）\n- 終了時刻（To）のドロップダウン表示（8:30, 9:00, 9:30, ...）\n- バリデーション（Toは From より後の時刻であること）\n- 未選択 = 全時間帯検索\n\n### 5. LoadingSpinner コンポーネント\n\n**目的**: ローディング状態の視覚表示\n\n**ファイル**: `src/components/ui/LoadingSpinner.tsx`\n\n**Props:**\n```typescript\ninterface LoadingSpinnerProps {\n  message?: string;  // 「施設情報を取得中...」など\n}\n```\n\n**依存関係:** なし\n\n**責任:**\n- アニメーション付きスピナー表示\n- 進行状況メッセージ表示\n\n### 6. FacilityCard コンポーネント\n\n**目的**: 施設情報と空き状況を表示するカード\n\n**ファイル**: `src/components/FacilityCard.tsx`\n\n**Props:**\n```typescript\ninterface FacilityCardProps {\n  facility: Facility;\n  availability: AvailabilityData[];\n}\n\ninterface Facility {\n  id: string;\n  name: string;\n}\n\ninterface AvailabilityData {\n  date: Date;\n  slots: TimeSlot[];\n}\n\ninterface TimeSlot {\n  time: string;        // \"8:30\", \"9:00\", etc.\n  available: boolean;  // true = 空き, false = 空いていない\n}\n```\n\n**依存関係:**\n- `AvailabilityList` (子コンポーネント)\n- `date-fns` (日付フォーマット)\n\n**責任:**\n- 施設名の表示\n- 日付ごとの空き状況表示\n- 展開/折りたたみ状態管理\n\n### 7. AvailabilityList コンポーネント\n\n**目的**: 時間帯ごとの空き状況リスト\n\n**ファイル**: `src/components/AvailabilityList.tsx`\n\n**Props:**\n```typescript\ninterface AvailabilityListProps {\n  slots: TimeSlot[];\n  showAll: boolean;  // true = 全時間帯, false = 空きのみ\n  onToggle: () => void;\n}\n```\n\n**依存関係:** なし\n\n**責任:**\n- 時間帯リストの表示\n- 空き/空いていないの視覚的区別\n- 展開ボタンの表示\n\n### 8. ErrorMessage コンポーネント\n\n**目的**: エラーメッセージと再試行ボタンの表示\n\n**ファイル**: `src/components/ui/ErrorMessage.tsx`\n\n**Props:**\n```typescript\ninterface ErrorMessageProps {\n  type: 'network' | 'timeout' | 'scraping' | 'validation';\n  onRetry?: () => void;\n}\n```\n\n**依存関係:** なし\n\n**責任:**\n- エラータイプに応じたメッセージ表示\n- 再試行ボタンの表示\n\n### 9. API Route: /api/scrape\n\n**目的**: スクレイピング処理を実行してデータを返す\n\n**ファイル**: `src/app/api/scrape/route.ts`\n\n**リクエスト:**\n```typescript\ninterface ScrapeRequest {\n  dates: string[];         // ISO 8601形式の日付配列\n  timeRange?: TimeRange;   // オプションの時間範囲\n}\n\ninterface TimeRange {\n  from: string;  // 開始時刻（例: \"9:00\"）\n  to: string;    // 終了時刻（例: \"12:00\"）\n}\n```\n\n**レスポンス:**\n```typescript\ninterface ScrapeResponse {\n  facilities: FacilityAvailability[];\n}\n\ninterface FacilityAvailability {\n  facility: Facility;\n  availability: AvailabilityData[];\n}\n```\n\n**依存関係:**\n- `scrapeFacilities` (lib/scraper)\n- `rateLimiter` (lib/scraper/rateLimiter)\n\n**責任:**\n- リクエストのバリデーション\n- スクレイピング実行\n- レート制限の適用\n- エラーハンドリング\n- JSONレスポンスの返却\n\n\n## データモデル\n\n### Facility（施設）\n\n```typescript\ninterface Facility {\n  id: string;         // 施設の一意識別子\n  name: string;       // 施設名（例: \"宇美町立体育館\"）\n  type: 'basketball' | 'mini-basketball';  // スポーツ種目\n}\n```\n\n### AvailabilityData（空き状況データ）\n\n```typescript\ninterface AvailabilityData {\n  date: Date;              // 対象日付\n  slots: TimeSlot[];       // 時間帯ごとの空き状況\n}\n```\n\n### TimeSlot（時間帯）\n\n```typescript\ninterface TimeSlot {\n  time: string;        // 時刻（\"8:30\", \"9:00\", etc.）\n  available: boolean;  // true = 空き, false = 空いていない\n}\n```\n\n### SearchParams（検索パラメータ）\n\n```typescript\ninterface SearchParams {\n  dates: Date[];           // 検索対象日付の配列\n  timeRange?: TimeRange;   // 指定時間範囲（オプション）\n}\n\ninterface TimeRange {\n  from: string;  // 開始時刻（例: \"9:00\"）\n  to: string;    // 終了時刻（例: \"12:00\"）\n}\n```\n\n### ScrapeRequest / ScrapeResponse（API型）\n\n```typescript\n// POST /api/scrape リクエスト\ninterface ScrapeRequest {\n  dates: string[];         // ISO 8601形式の日付配列\n  timeRange?: TimeRange;   // オプションの時間範囲\n}\n\ninterface TimeRange {\n  from: string;  // 開始時刻（例: \"9:00\"）\n  to: string;    // 終了時刻（例: \"12:00\"）\n}\n\n// POST /api/scrape レスポンス\ninterface ScrapeResponse {\n  facilities: FacilityAvailability[];\n}\n\ninterface FacilityAvailability {\n  facility: Facility;\n  availability: AvailabilityData[];\n}\n\n// エラーレスポンス\ninterface ErrorResponse {\n  error: string;\n  message: string;\n  retryable: boolean;\n}\n```\n\n## スクレイピング設計\n\n### スクレイピングフロー\n\n```mermaid\nsequenceDiagram\n    participant UI as フロントエンド\n    participant API as /api/scrape\n    participant RL as RateLimiter\n    participant SC as Scraper\n    participant EXT as 宇美町システム\n\n    UI->>API: POST /api/scrape\n    API->>RL: checkRateLimit()\n    alt レート制限OK\n        RL-->>API: OK\n        API->>SC: scrapeFacilities(params)\n        SC->>EXT: navigate to system\n        EXT-->>SC: HTML response\n        SC->>SC: parse HTML\n        SC-->>API: FacilityAvailability[]\n        API-->>UI: JSON response\n    else レート制限NG\n        RL-->>API: Error\n        API-->>UI: 429 Too Many Requests\n    end\n```\n\n### Scraper クラス\n\n**ファイル**: `src/lib/scraper/index.ts`\n\n**責任:**\n- Puppeteerブラウザの起動\n- ページナビゲーション\n- HTML解析\n- データ抽出\n\n**主要メソッド:**\n\n```typescript\nclass FacilityScraper {\n  private browser: Browser | null = null;\n\n  /**\n   * スクレイピング実行\n   */\n  async scrapeFacilities(\n    dates: Date[],\n    timeRange?: TimeRange\n  ): Promise<FacilityAvailability[]> {\n    await this.initBrowser();\n    \n    try {\n      const page = await this.browser!.newPage();\n      await this.navigateToSearchPage(page);\n      await this.selectSports(page, ['basketball', 'mini-basketball']);\n      const facilities = await this.selectAllFacilities(page);\n      \n      const results: FacilityAvailability[] = [];\n      \n      for (const facility of facilities) {\n        const availability = await this.scrapeAvailability(\n          page,\n          facility,\n          dates,\n          timeRange\n        );\n        results.push({ facility, availability });\n      }\n      \n      return results;\n    } finally {\n      await this.closeBrowser();\n    }\n  }\n\n  /**\n   * ブラウザ初期化\n   */\n  private async initBrowser(): Promise<void> {\n    this.browser = await puppeteer.launch({\n      headless: true,\n      args: ['--no-sandbox', '--disable-setuid-sandbox']\n    });\n  }\n\n  /**\n   * 検索ページへのナビゲーション\n   */\n  private async navigateToSearchPage(page: Page): Promise<void> {\n    await page.goto('https://www.11489.jp/Umi/web/Home/WgR_ModeSelect', {\n      waitUntil: 'networkidle0',\n      timeout: 10000\n    });\n  }\n\n  /**\n   * スポーツ種目選択\n   */\n  private async selectSports(\n    page: Page,\n    sports: string[]\n  ): Promise<void> {\n    // スポーツ選択ロジック\n  }\n\n  /**\n   * 施設一覧取得\n   */\n  private async selectAllFacilities(page: Page): Promise<Facility[]> {\n    // 施設一覧取得ロジック\n  }\n\n  /**\n   * 空き状況スクレイピング\n   */\n  private async scrapeAvailability(\n    page: Page,\n    facility: Facility,\n    dates: Date[],\n    timeRange?: TimeRange\n  ): Promise<AvailabilityData[]> {\n    // 空き状況スクレイピングロジック\n    // timeRangeが指定されている場合は、from-toの範囲のみフィルタリング\n  }\n\n  /**\n   * ブラウザクローズ\n   */\n  private async closeBrowser(): Promise<void> {\n    if (this.browser) {\n      await this.browser.close();\n      this.browser = null;\n    }\n  }\n}\n```\n\n### HTMLParser\n\n**ファイル**: `src/lib/scraper/parser.ts`\n\n**責任:**\n- HTMLからデータ抽出\n- DOM要素の解析\n- データ構造への変換\n\n**主要関数:**\n\n```typescript\n/**\n * 施設一覧をHTMLから抽出\n */\nexport function parseFacilities(html: string): Facility[] {\n  const $ = cheerio.load(html);\n  const facilities: Facility[] = [];\n  \n  $('.facility-item').each((_, element) => {\n    const id = $(element).attr('data-facility-id');\n    const name = $(element).find('.facility-name').text();\n    const type = $(element).attr('data-sport-type');\n    \n    if (id && name && type) {\n      facilities.push({ id, name, type: type as any });\n    }\n  });\n  \n  return facilities;\n}\n\n/**\n * 空き状況をHTMLから抽出\n */\nexport function parseAvailability(html: string, date: Date): TimeSlot[] {\n  const $ = cheerio.load(html);\n  const slots: TimeSlot[] = [];\n  \n  $('.time-slot').each((_, element) => {\n    const time = $(element).attr('data-time');\n    const available = $(element).hasClass('available');\n    \n    if (time) {\n      slots.push({ time, available });\n    }\n  });\n  \n  return slots;\n}\n```\n\n### RateLimiter\n\n**ファイル**: `src/lib/scraper/rateLimiter.ts`\n\n**責任:**\n- リクエスト間隔の制御\n- 同時リクエスト数の制限\n\n**実装:**\n\n```typescript\nclass RateLimiter {\n  private lastRequestTime: number = 0;\n  private readonly MIN_INTERVAL = 5000; // 5秒\n  private requestInProgress: boolean = false;\n\n  /**\n   * レート制限チェック\n   */\n  async checkRateLimit(): Promise<void> {\n    // 同時リクエストチェック\n    if (this.requestInProgress) {\n      throw new Error('Another request is in progress');\n    }\n\n    // 最小間隔チェック\n    const now = Date.now();\n    const timeSinceLastRequest = now - this.lastRequestTime;\n    \n    if (timeSinceLastRequest < this.MIN_INTERVAL) {\n      const waitTime = this.MIN_INTERVAL - timeSinceLastRequest;\n      await this.sleep(waitTime);\n    }\n\n    this.requestInProgress = true;\n    this.lastRequestTime = Date.now();\n  }\n\n  /**\n   * リクエスト完了を通知\n   */\n  releaseRequest(): void {\n    this.requestInProgress = false;\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n\nexport const rateLimiter = new RateLimiter();\n```\n\n\n## エラーハンドリング\n\n### エラーシナリオ\n\n#### 1. ネットワークエラー\n\n**説明**: インターネット接続が切断されている、または宇美町システムが応答しない\n\n**処理方法:**\n- 1回の自動再試行を実行\n- 2回目も失敗した場合、エラーレスポンスを返す\n\n**ユーザーへの影響:**\n```typescript\n{\n  error: 'NetworkError',\n  message: 'インターネット接続を確認してください',\n  retryable: true\n}\n```\n\n**実装:**\n```typescript\nasync function fetchWithRetry(\n  fn: () => Promise<any>,\n  retries: number = 1\n): Promise<any> {\n  try {\n    return await fn();\n  } catch (error) {\n    if (retries > 0) {\n      await sleep(2000);\n      return await fetchWithRetry(fn, retries - 1);\n    }\n    throw error;\n  }\n}\n```\n\n#### 2. タイムアウトエラー\n\n**説明**: スクレイピング処理が10秒を超えた\n\n**処理方法:**\n- Puppeteerのタイムアウト設定（10秒）\n- タイムアウト時にエラーを投げる\n\n**ユーザーへの影響:**\n```typescript\n{\n  error: 'TimeoutError',\n  message: '処理に時間がかかっています。もう一度お試しください',\n  retryable: true\n}\n```\n\n**実装:**\n```typescript\nawait page.goto(url, {\n  waitUntil: 'networkidle0',\n  timeout: 10000  // 10秒\n});\n```\n\n#### 3. HTML構造変更エラー\n\n**説明**: 宇美町システムのHTML構造が変更され、期待する要素が見つからない\n\n**処理方法:**\n- 要素の存在チェック\n- 見つからない場合は具体的なエラーを投げる\n\n**ユーザーへの影響:**\n```typescript\n{\n  error: 'ScrapingError',\n  message: 'データの取得に失敗しました。しばらく経ってから再度お試しください',\n  retryable: false\n}\n```\n\n**実装:**\n```typescript\nconst element = await page.$('.expected-element');\nif (!element) {\n  throw new Error('HTML structure changed: .expected-element not found');\n}\n```\n\n#### 4. バリデーションエラー\n\n**説明**: ユーザーが日付を選択していない\n\n**処理方法:**\n- フロントエンドでバリデーション\n- APIでも二重チェック\n\n**ユーザーへの影響:**\n```typescript\n{\n  error: 'ValidationError',\n  message: '日付を選択してください',\n  retryable: false\n}\n```\n\n**実装:**\n```typescript\n// フロントエンド\nif (selectedDates.length === 0) {\n  setError('日付を選択してください');\n  return;\n}\n\n// API\nif (!dates || dates.length === 0) {\n  return NextResponse.json(\n    { error: 'ValidationError', message: '日付を選択してください' },\n    { status: 400 }\n  );\n}\n```\n\n#### 5. レート制限エラー\n\n**説明**: 5秒以内に連続してリクエストが送信された\n\n**処理方法:**\n- RateLimiterでチェック\n- 429エラーを返す\n\n**ユーザーへの影響:**\n```typescript\n{\n  error: 'RateLimitError',\n  message: 'しばらく待ってから再度お試しください',\n  retryable: true\n}\n```\n\n## テスト戦略\n\n### ユニットテスト\n\nrequirements.mdに従い、TDDアプローチでユニットテストを実装します。\n\n**テストフレームワーク**: Vitest\n\n**テスト対象:**\n\n1. **日付ユーティリティ** (`lib/utils/date.ts`)\n   ```typescript\n   describe('日付範囲生成', () => {\n     it('本日から7日分の日付配列を生成できること', () => {\n       const result = generateDateRange(new Date(), 7);\n       expect(result).toHaveLength(7);\n     });\n   });\n   ```\n\n2. **バリデーション** (`lib/utils/validation.ts`)\n   ```typescript\n   describe('検索パラメータのバリデーション', () => {\n     it('日付が空の配列の場合はエラーを投げること', () => {\n       expect(() => validateSearchParams({ dates: [] })).toThrow();\n     });\n\n     it('時間範囲のFromがToより後の場合はエラーを投げること', () => {\n       expect(() => validateSearchParams({\n         dates: [new Date()],\n         timeRange: { from: '12:00', to: '9:00' }\n       })).toThrow();\n     });\n   });\n   ```\n\n3. **HTMLパーサー** (`lib/scraper/parser.ts`)\n   ```typescript\n   describe('施設情報のHTMLパース', () => {\n     it('HTMLから施設情報を抽出できること', () => {\n       const html = '<div class=\"facility-item\" data-facility-id=\"1\">...</div>';\n       const facilities = parseFacilities(html);\n       expect(facilities).toHaveLength(1);\n     });\n   });\n   ```\n\n4. **RateLimiter** (`lib/scraper/rateLimiter.ts`)\n   ```typescript\n   describe('レート制限', () => {\n     it('5秒間隔を強制すること', async () => {\n       const limiter = new RateLimiter();\n       await limiter.checkRateLimit();\n       const start = Date.now();\n       await limiter.checkRateLimit();\n       const duration = Date.now() - start;\n       expect(duration).toBeGreaterThanOrEqual(5000);\n     });\n   });\n   ```\n\n**テストカバレッジ目標:**\n- ビジネスロジック: 80%以上\n- ユーティリティ関数: 90%以上\n\n### E2Eテスト\n\nrequirements.mdに従い、初期バージョンではE2Eテストは実装しません。将来的な拡張として検討します。\n\n## 非機能要件の実装\n\n### パフォーマンス最適化\n\n1. **初回表示時間（2秒以内）**\n   - Next.js App Routerのサーバーコンポーネント活用\n   - TailwindCSSのPurge設定（未使用CSS削除）\n   - フォントの最適化（next/font）\n\n2. **検索結果取得時間（10秒以内）**\n   - Puppeteerのタイムアウト設定（10秒）\n   - 並列処理の検討（複数施設の同時スクレイピング - 要検討）\n\n3. **バンドルサイズ（300KB以下）**\n   - Dynamic Importの活用\n   - Tree Shakingの最適化\n   - Puppeteerはサーバーサイドのみで使用\n\n### セキュリティ対策\n\n1. **HTTPS通信**\n   - Vercelのデフォルト証明書を使用\n   - すべてのリクエストをHTTPSで実行\n\n2. **XSS対策**\n   - Reactのデフォルトエスケープを活用\n   - `dangerouslySetInnerHTML`は使用禁止\n\n3. **スクレイピング先への配慮**\n   - User-Agentヘッダーの設定\n   ```typescript\n   await page.setUserAgent(\n     'Mozilla/5.0 (compatible; UmiFacilitySearch/1.0)'\n   );\n   ```\n   - Rate Limiterによる5秒間隔の強制\n\n4. **環境変数の管理**\n   - `.env.local`でローカル環境変数を管理\n   - センシティブ情報はVercelの環境変数として設定\n\n### モバイル最適化\n\n1. **タッチターゲットサイズ**\n   - すべてのタップ可能な要素を44px × 44px以上に設定\n   ```css\n   .tap-target {\n     min-width: 44px;\n     min-height: 44px;\n   }\n   ```\n\n2. **フォントサイズ**\n   - 本文: 16px以上\n   - 見出し: 階層的なサイズ（20px, 24px, 32px）\n\n3. **レスポンシブデザイン**\n   - TailwindCSSのブレークポイント活用\n   ```tsx\n   <div className=\"w-full sm:w-1/2 lg:w-1/3\">\n   ```\n\n### 信頼性向上\n\n1. **エラーバウンダリ**\n   - Next.js App Routerの`error.tsx`を活用\n   ```typescript\n   // app/error.tsx\n   'use client';\n   \n   export default function Error({\n     error,\n     reset,\n   }: {\n     error: Error;\n     reset: () => void;\n   }) {\n     return (\n       <div>\n         <h2>エラーが発生しました</h2>\n         <button onClick={reset}>再試行</button>\n       </div>\n     );\n   }\n   ```\n\n2. **ローディング状態**\n   - Next.js App Routerの`loading.tsx`を活用\n   ```typescript\n   // app/loading.tsx\n   export default function Loading() {\n     return <LoadingSpinner message=\"読み込み中...\" />;\n   }\n   ```\n\n3. **再試行ロジック**\n   - ネットワークエラー時に1回の自動再試行\n   - ユーザー操作による手動再試行ボタン\n\n## デプロイ設計\n\n### Vercelデプロイ設定\n\n**vercel.json:**\n```json\n{\n  \"buildCommand\": \"pnpm build\",\n  \"devCommand\": \"pnpm dev\",\n  \"installCommand\": \"pnpm install\",\n  \"framework\": \"nextjs\",\n  \"regions\": [\"hnd1\"]\n}\n```\n\n**環境変数:**\n- `NODE_ENV`: production\n- `NEXT_PUBLIC_APP_URL`: アプリケーションURL（将来的に使用）\n\n### ビルド最適化\n\n**next.config.js:**\n```javascript\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  reactStrictMode: true,\n  swcMinify: true,\n  compress: true,\n  poweredByHeader: false,\n  \n  // Puppeteer用の設定\n  experimental: {\n    serverComponentsExternalPackages: ['puppeteer']\n  }\n};\n\nmodule.exports = nextConfig;\n```\n\n## まとめ\n\n本設計ドキュメントは、requirements.mdで定義されたすべての要件を実現するための技術設計を詳細に定義しました。\n\n**主要な設計決定:**\n1. Next.js 15.x App Routerの活用\n2. モジュラーなコンポーネント設計\n3. Puppeteerによる信頼性の高いスクレイピング\n4. TDDアプローチによるユニットテスト\n5. モバイルファーストのレスポンシブデザイン\n\n**次のステップ:**\n- tasks.mdでの実装タスクへの分解\n- TDDアプローチでの実装開始\n",
  "fileStats": {
    "size": 26878,
    "lines": 1051,
    "lastModified": "2025-12-05T14:55:41.984Z"
  },
  "comments": []
}